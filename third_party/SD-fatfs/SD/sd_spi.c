#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdio.h>

#include "hardware/spi.h"
#include "hardware/gpio.h"
#include "ff.h"			/* Obtains integer types */
#include "diskio.h"		/* Declarations of disk functions */
#include "picostation_pinout.h"

#define MAX_RETRIES     500000
#define READ_RETRIES    50000
#define WRITE_RETRIES   150000

#define CS_ON	0
#define CS_OFF	1

#define CMD(n) ((n) | 0x40)

#define SPI_FILL_CHAR (0xFF)

#define SD_BAUD_RATE (30 * 1000 * 1000)

#define spi_set_cs(val) gpio_put(GPIO_SD_CS, val);

static bool byte_mode = false;
static bool is_mmc = false;
static bool initted = false;

/* Table/algorithm generated by pycrc. I really wanted to have a much smaller
   table here, but unfortunately, the code pycrc generated just did not work. */
static const uint8_t crc7_table[256] = {
    0x00, 0x12, 0x24, 0x36, 0x48, 0x5a, 0x6c, 0x7e,
    0x90, 0x82, 0xb4, 0xa6, 0xd8, 0xca, 0xfc, 0xee,
    0x32, 0x20, 0x16, 0x04, 0x7a, 0x68, 0x5e, 0x4c,
    0xa2, 0xb0, 0x86, 0x94, 0xea, 0xf8, 0xce, 0xdc,
    0x64, 0x76, 0x40, 0x52, 0x2c, 0x3e, 0x08, 0x1a,
    0xf4, 0xe6, 0xd0, 0xc2, 0xbc, 0xae, 0x98, 0x8a,
    0x56, 0x44, 0x72, 0x60, 0x1e, 0x0c, 0x3a, 0x28,
    0xc6, 0xd4, 0xe2, 0xf0, 0x8e, 0x9c, 0xaa, 0xb8,
    0xc8, 0xda, 0xec, 0xfe, 0x80, 0x92, 0xa4, 0xb6,
    0x58, 0x4a, 0x7c, 0x6e, 0x10, 0x02, 0x34, 0x26,
    0xfa, 0xe8, 0xde, 0xcc, 0xb2, 0xa0, 0x96, 0x84,
    0x6a, 0x78, 0x4e, 0x5c, 0x22, 0x30, 0x06, 0x14,
    0xac, 0xbe, 0x88, 0x9a, 0xe4, 0xf6, 0xc0, 0xd2,
    0x3c, 0x2e, 0x18, 0x0a, 0x74, 0x66, 0x50, 0x42,
    0x9e, 0x8c, 0xba, 0xa8, 0xd6, 0xc4, 0xf2, 0xe0,
    0x0e, 0x1c, 0x2a, 0x38, 0x46, 0x54, 0x62, 0x70,
    0x82, 0x90, 0xa6, 0xb4, 0xca, 0xd8, 0xee, 0xfc,
    0x12, 0x00, 0x36, 0x24, 0x5a, 0x48, 0x7e, 0x6c,
    0xb0, 0xa2, 0x94, 0x86, 0xf8, 0xea, 0xdc, 0xce,
    0x20, 0x32, 0x04, 0x16, 0x68, 0x7a, 0x4c, 0x5e,
    0xe6, 0xf4, 0xc2, 0xd0, 0xae, 0xbc, 0x8a, 0x98,
    0x76, 0x64, 0x52, 0x40, 0x3e, 0x2c, 0x1a, 0x08,
    0xd4, 0xc6, 0xf0, 0xe2, 0x9c, 0x8e, 0xb8, 0xaa,
    0x44, 0x56, 0x60, 0x72, 0x0c, 0x1e, 0x28, 0x3a,
    0x4a, 0x58, 0x6e, 0x7c, 0x02, 0x10, 0x26, 0x34,
    0xda, 0xc8, 0xfe, 0xec, 0x92, 0x80, 0xb6, 0xa4,
    0x78, 0x6a, 0x5c, 0x4e, 0x30, 0x22, 0x14, 0x06,
    0xe8, 0xfa, 0xcc, 0xde, 0xa0, 0xb2, 0x84, 0x96,
    0x2e, 0x3c, 0x0a, 0x18, 0x66, 0x74, 0x42, 0x50,
    0xbe, 0xac, 0x9a, 0x88, 0xf6, 0xe4, 0xd2, 0xc0,
    0x1c, 0x0e, 0x38, 0x2a, 0x54, 0x46, 0x70, 0x62,
    0x8c, 0x9e, 0xa8, 0xba, 0xc4, 0xd6, 0xe0, 0xf2
};

static uint8_t sd_crc7(const uint8_t *data, int size, uint8_t crc) {
    int tbl_idx;

    while(size--) {
        tbl_idx = (crc ^ *data) & 0xff;
        crc = (crc7_table[tbl_idx] ^ (crc << 7)) & (0x7f << 1);

        data++;
    }

    return crc & (0x7f << 1);
}

static uint8_t spi_read_byte() {
    uint8_t received = SPI_FILL_CHAR;
	spi_read_blocking(spi1, SPI_FILL_CHAR, &received, 1);
    return received;
}

static void spi_write_byte(const uint8_t value) {
	spi_write_blocking(spi1, &value, 1);
}

static int sd_send_cmd(uint8_t cmd, uint32_t arg) {
    uint8_t rv;
    int i = 0;
    uint8_t pkt[6];

    /* Wait for the SD card to be ready to accept our command... */
    spi_read_byte();
    
    do {
        rv = spi_read_byte();
        ++i;
    } while(rv != 0xFF && i < MAX_RETRIES);

    /* If we never got a response, something's wrong... bail out */
    if(rv != 0xFF) {
        return -1;
	}

    /* Pack up the packet */
    pkt[0] = cmd;
    pkt[1] = (uint8_t)(arg >> 24);
    pkt[2] = (uint8_t)(arg >> 16);
    pkt[3] = (uint8_t)(arg >>  8);
    pkt[4] = (uint8_t)(arg >>  0);
    pkt[5] = sd_crc7(pkt, 5, 0) | 0x01;

    /* Write out the packet to the device */
    spi_write_blocking(spi1, pkt, sizeof(pkt));

    /* Ignore the first byte after sending a CMD12 */
    if(cmd == CMD(12)) {
        spi_read_byte();
	}

    /* Wait for a response */
    i = 0;
    do {
        rv = spi_read_byte();
        ++i;
    } while((rv & 0x80) && i < 20);


    if(rv & 0x80) {
        return -1;
	}

    return (int)rv;
}

static int acmd41_loop(uint32_t arg) {
    int i = 0, rv;

    /* Try to send ACMD41 for a while. It could take up to 1 second to come
       back to us, but will likely take much less. */
    while(i++ < MAX_RETRIES) {
        if(sd_send_cmd(CMD(55), 0) > 1) {
            return -1;
		}

        if((rv = sd_send_cmd(CMD(41), arg)) > 1) {
            return -1;
		}

        if(rv == 0) {
            break;
		}
    }

    /* If we get this far, it isn't going to come back. */
    if(i == MAX_RETRIES) {
        return -2;
	}

    return 0;
}

static int cmd1_loop(void) {
    int i = 0, rv;

    /* Try to send CMD1 for a while. It could take up to 1 second to come
       back to us, but will likely take much less. */
    while(i++ < MAX_RETRIES) {
        if((rv = sd_send_cmd(CMD(1), 0)) > 1) {
            return -1;
		}

        if(rv == 0) {
            break;
		}
    }

    /* If we get this far, it isn't going to come back. */
    if(i == MAX_RETRIES) {
        return -2;
	}

    return 0;
}

int sd_init() {
    int i;
    uint8_t buf[4];
    
    if(initted) {
        return 0;
	}

    byte_mode = is_mmc = false;

    /* Initialize interface with low speed for reliability */
    spi_init(spi1, 250 * 1000);
    spi_set_format(spi1, 8, SPI_CPOL_1, SPI_CPHA_1, SPI_MSB_FIRST);
    
	gpio_set_function(GPIO_SD_MISO, GPIO_FUNC_SPI);
	gpio_set_function(GPIO_SD_MOSI, GPIO_FUNC_SPI);
	gpio_set_function(GPIO_SD_SCK, GPIO_FUNC_SPI);
	
	gpio_set_slew_rate(GPIO_SD_SCK, GPIO_SLEW_RATE_FAST);
	
	gpio_set_drive_strength(GPIO_SD_MOSI, GPIO_DRIVE_STRENGTH_4MA);
	gpio_set_drive_strength(GPIO_SD_SCK, GPIO_DRIVE_STRENGTH_12MA);
	
	gpio_pull_up(GPIO_SD_MISO);
	
    /* Send 10 idle bytes so as to delay the required number of clock cycles
       after asserting the /CS pin (we have to delay at least 74 clock cycles,
       and sending 10 idle bytes is 80 cycles). Once that is done, deassert the
       /CS line. */
	
    for(i = 0; i < 10; ++i) {
        spi_read_byte();
    }

    spi_set_cs(CS_ON);

    /* Reset the card, putting it in its idle state. */
    if(sd_send_cmd(CMD(0), 0) != 1) {
        spi_set_cs(CS_OFF);
        return -1;
    }

    /* Detect if we're using a v2 SD card. */
    if(sd_send_cmd(CMD(8), 0x000001AA) == 1) {
        buf[0] = spi_read_byte();
        buf[1] = spi_read_byte();
        buf[2] = spi_read_byte();
        buf[3] = spi_read_byte();

        if((buf[2] & 0x0F) != 0x01 || buf[3] != 0xAA) {
            spi_set_cs(CS_OFF);
            return -2;
        }

        /* ACMD41 until we're ready */
        if(acmd41_loop(0x40000000)) {
            spi_set_cs(CS_OFF);
            return -1;
        }

        /* Detect if we do byte addressing or block addressing with CMD58 */
        if(sd_send_cmd(CMD(58), 0)) {
            spi_set_cs(CS_OFF);
            return -1;
        }

        buf[0] = spi_read_byte();
        buf[1] = spi_read_byte();
        buf[2] = spi_read_byte();
        buf[3] = spi_read_byte();

        if(!(buf[0] & 0x40)) {
            byte_mode = true;
		}
    }
    else {
        /* ACMD41 (SDv1) or CMD1 (MMC) until we're ready */
        if(acmd41_loop(0)) {
            /* Try with CMD1 instead then... */
            if(cmd1_loop()) {
                spi_set_cs(CS_OFF);
                return -1;
            }

            /* If ACMD41 failed but CMD1 succeeded, we have a MMC card. */
            is_mmc = true;
        }

        /* Set the block length to 512 with CMD16 */
        if(sd_send_cmd(CMD(16), 512)) {
            spi_set_cs(CS_OFF);
            return -1;
        }

        /* v1 cards always use byte addressing. */
        byte_mode = true;
    }
    
     /* Re-enable CRC checking. */
	/*if(sd_send_cmd(CMD(59), 1)) {
		printf("CMD59 error\n");
        spi_set_cs(false);
        return -1;
    }*/
    
    /* Make sure that the card releases the data line */
    spi_set_cs(CS_OFF);
    spi_write_byte(SPI_FILL_CHAR);

    /* Switch to maximum speed after successful initialization */
	spi_set_baudrate(spi1, SD_BAUD_RATE);

    initted = true;
    return 0;
}

static int read_data(size_t bytes, uint8_t *buf) {
    uint8_t byte;
    int i = 0;

    /* This should come back in 100ms at worst... */
    do {
        byte = spi_read_byte();
        ++i;
    } while(byte == 0xFF && i < READ_RETRIES);

    if(byte != 0xFE)
        return -1;

    /* Read in the data */
    /*while(bytes--) {
        spi_read_byte(*buf++);
    }*/
    
    spi_read_blocking(spi1, SPI_FILL_CHAR, buf, bytes);

	(void)spi_read_byte();
	(void)spi_read_byte();
	
	return 0;
}

int sd_read_blocks(uint32_t block, size_t count, uint8_t *buf) {
    int rv = 0;

    if(!initted) {
        return -1;
    }

    /* If we're in byte addressing mode, scale the block up. */
    if(byte_mode) {
        block <<= 9;
	}

    spi_set_cs(CS_ON);

    if(count == 1) {
        /* Ask the card for the block */
        if(sd_send_cmd(CMD(17), block)) {
            rv = -1;
            goto out;
        }

        /* Read the block back */
        if(read_data(512, buf)) {
            rv = -1;
            goto out;
        }
    }
    else {
        /* Set up the multi-block read */
        if(sd_send_cmd(CMD(18), block)) {
            rv = -1;
            goto out;
        }

        while(count--) {
            if(read_data(512, buf)) {
                rv = -1;
                goto out;
            }

            buf += 512;
        }

        /* Stop the data transfer */
        sd_send_cmd(CMD(12), 0);
    }

out:
    spi_set_cs(CS_OFF);
    spi_write_byte(SPI_FILL_CHAR);

    return rv;
}

static int write_data(uint8_t tag, size_t bytes, const uint8_t *buf) {
    uint8_t rv;
    int i = 0;
    //const uint8_t *ptr = buf;

    /* Wait for the card to be ready for our data */
    spi_write_byte(SPI_FILL_CHAR);
    
    do {
        rv = spi_read_byte();
        ++i;
    } while(rv != 0xFF && i < WRITE_RETRIES);

    if(rv != 0xFF) {
        return -1;
	}

    spi_write_byte(tag);

    /* Send the data. */
    /*while(bytes--) {
        spi_write_byte(*ptr++);
    }*/
    spi_write_blocking(spi1, buf, bytes);

    /* Write out the block's crc */
    spi_write_byte(SPI_FILL_CHAR);
    spi_write_byte(SPI_FILL_CHAR);

    /* Make sure the card accepted the block */
    rv = spi_read_byte();
    
    if((rv & 0x1F) != 0x05) {
        return -1;
	}

    return 0;
}

int sd_write_blocks(uint32_t block, size_t count, const uint8_t *buf) {
    int rv = 0, i = 0;
    uint8_t byte;

    if(!initted) {
        return -1;
    }

    /* If we're in byte addressing mode, scale the block up. */
    if(byte_mode) {
        block <<= 9;
	}

    spi_set_cs(CS_ON);

    if(count == 1) {
        /* Prepare the card for the block */
        if(sd_send_cmd(CMD(24), block)) {
            rv = -1;
            goto out;
        }

        /* Read the block back */
        if(write_data(0xFE, 512, buf)) {
            rv = -1;
            goto out;
        }
    }
    else {
        /* If we're on a SD card, inform the card ahead of time how many blocks
           we intend to write. */
        if(!is_mmc) {
            sd_send_cmd(CMD(55), 0);
            sd_send_cmd(CMD(23), count);
        }

        /* Set up the multi-block write */
        if(sd_send_cmd(CMD(25), block)) {
            rv = -1;
            goto out;
        }

        while(count--) {
            if(write_data(0xFC, 512, buf)) {
                /* Make sure we at least try to stop the transfer... */
                rv = -1;
                break;
            }

            buf += 512;
        }

        /* Write the end data token. */
        spi_write_byte(SPI_FILL_CHAR);
        do {
            byte = spi_read_byte(SPI_FILL_CHAR);
            ++i;
        } while(byte != 0xFF && i < WRITE_RETRIES);

        if(byte != 0xFF) {
            rv = -1;
            goto out;
        }

        spi_write_byte(0xFD);
    }

out:
    spi_set_cs(CS_OFF);
    spi_write_byte(SPI_FILL_CHAR);

    return rv;
}


DSTATUS disk_status(BYTE pdrv /* Physical drive number to identify the drive */
)
{
    return initted ? RES_OK : STA_NOINIT;
}

/*-----------------------------------------------------------------------*/
/* Inidialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(
    BYTE pdrv /* Physical drive number to identify the drive */
) {
	if(sd_init()) {
		return RES_NOTRDY;
	}
    
    // See http://elm-chan.org/fsw/ff/doc/dstat.html
    return initted ? RES_OK : STA_NOINIT;  
}

/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
/*-----------------------------------------------------------------------*/

DRESULT disk_read(BYTE pdrv,  /* Physical drive number to identify the drive */
                  BYTE *buff, /* Data buffer to store read data */
                  LBA_t sector, /* Start sector in LBA */
                  UINT count    /* Number of sectors to read */
)
{
    if(sd_read_blocks(sector, count, buff)) {
		return RES_ERROR;
	}
    
    return RES_OK;
}

/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
/*-----------------------------------------------------------------------*/

#if FF_FS_READONLY == 0

DRESULT disk_write(BYTE pdrv, /* Physical drive number to identify the drive */
                   const BYTE *buff, /* Data to be written */
                   LBA_t sector,     /* Start sector in LBA */
                   UINT count        /* Number of sectors to write */
)
{
	if(sd_write_blocks(sector, count, buff)) {
		return RES_ERROR;
	}
	
	return RES_OK;
}

#endif

/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

DRESULT disk_ioctl(BYTE pdrv, /* Physical drive number (0..) */
                   BYTE cmd,  /* Control code */
                   void *buff /* Buffer to send/receive control data */
)
{
	switch (cmd) {
        case GET_SECTOR_COUNT: {  // Retrieves number of available sectors, the
                                  // largest allowable LBA + 1, on the drive
                                  // into the LBA_t variable pointed by buff.
                                  // This command is used by f_mkfs and f_fdisk
                                  // function to determine the size of
                                  // volume/partition to be created. It is
                                  // required when FF_USE_MKFS == 1.
            *(LBA_t *)buff = 0;
            return RES_OK;
        }
        
        case GET_BLOCK_SIZE: {  // Retrieves erase block size of the flash
                                // memory media in unit of sector into the DWORD
                                // variable pointed by buff. The allowable value
                                // is 1 to 32768 in power of 2. Return 1 if the
                                // erase block size is unknown or non flash
                                // memory media. This command is used by only
                                // f_mkfs function and it attempts to align data
                                // area on the erase block boundary. It is
                                // required when FF_USE_MKFS == 1.
            static DWORD bs = 1;
            *(DWORD *)buff = bs;
            return RES_OK;
        }
        
        case CTRL_SYNC: {
            return RES_OK;
		}
        
        default:
            return RES_PARERR;
    }
}

